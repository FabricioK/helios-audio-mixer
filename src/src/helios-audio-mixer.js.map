{"version":3,"sources":["src/node_modules/browserify/node_modules/browser-pack/_prelude.js","src/src/bundle-standalone.js","src/src/debug.js","src/src/detect.js","src/src/mix.js","src/src/track-html5.js","src/src/track.js","src/src/utils.js"],"names":[],"mappings":"AAAA;ACAA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACj8BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"helios-audio-mixer.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var mix = require('./mix');\nwindow.heliosAudioMixer = mix;","/*\n\n  Debug\n\n*/\n\nvar u = require('./utils')\n\nvar debug = {};\nmodule.exports = debug;\n\n// 0 no logging, 1 minimal, 2 all (spammy)\ndebug.level = 1;\n\n// u.log(1, arg, arg, arg) -> console.log('[Mixer] arg arg arg')\ndebug.log = function(lvl) {\n  if(lvl <= debug.level) {\n    var str = '[Mixer] '\n    for (var i = 1; i < arguments.length; i++)\n      str += arguments[i] + ' '\n    console.log(str)\n  }\n}\n\ndebug.setLogLvl = function(lvl) {\n  this.debug = u.constrain(lvl, 0, 2);\n  debug.log(1, 'Set log level:', lvl)\n}","var detect = {};\n\n// Web audio API support\ndetect.webAudio = !!(window.AudioContext || window.webkitAudioContext),\n\n// Which audio types can the browser actually play?\ndetect.audioTypes =(function() {\n  var el = document.createElement('audio')\n\n  return {\n    '.m4a': !!(el.canPlayType && el.canPlayType('audio/mp4; codecs=\"mp4a.40.2\"').replace(/no/, '')),\n    '.mp3': !!(el.canPlayType && el.canPlayType('audio/mpeg;').replace(/no/, '')),\n    '.ogg': !!(el.canPlayType && el.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/no/, ''))\n  }\n})(),\n\ndetect.videoTypes = (function() {\n\n  var el = document.createElement('video')\n\n  return {\n    '.webm': !!(el.canPlayType && el.canPlayType('video/webm; codecs=\"vp8, vorbis\"').replace(/no/, '')),\n    '.mp4':  !!(el.canPlayType && el.canPlayType('video/mp4; codecs=\"avc1.42E01E, mp4a.40.2\"').replace(/no/, '')),\n    '.ogv':  !!(el.canPlayType && el.canPlayType('video/ogg; codecs=\"theora\"').replace(/no/, ''))\n  }\n})(),\n\n// prefer bowser, but with fallback\ndetect.browser = (function() {\n\n  if(typeof bowser !== 'undefined') return bowser;\n\n  return {\n    firefox: !!navigator.userAgent.match(/Firefox/g),\n    android: !!navigator.userAgent.match(/Android/g),\n    msie:    !!navigator.userAgent.match(/MSIE/g),\n    ios:     !!navigator.userAgent.match(/(iPad|iPhone|iPod)/g),\n\n    version: false\n  };\n})(),\n\n// is tween.js present?\ndetect.tween = (function() {\n  return (typeof TWEEN === 'undefined') ? false : true\n})()\n\nmodule.exports = detect;","/*\n\n  ###  ### #### ##   ##\n  ########  ##   ## ##\n  ## ## ##  ##    ###\n  ##    ##  ##   ## ##\n  ##    ## #### ##   ##\n\n*/\n\nvar u = require('./utils')\nvar Track = require('./track')\nvar html5Track = require('./track-html5')\nvar detect = require('./detect')\nvar debug = require('./debug')\n\n\nvar Mix = function(opts) {\n\n  // Web Audio support overrides\n  if(\n    (detect.browser.name === 'Firefox' && detect.version && detect.version < 25) || // Firefox < 25\n    (detect.browser.ios === true && detect.browser.version === 7)                   // ios 7\n  ) {\n    detect.webAudio = false;\n  }\n\n  var defaults = {\n    fileTypes: [ '.mp3', '.m4a', '.ogg' ],\n    html5: !!detect.webAudio,\n    gain: 1, // master gain for entire mix\n  }\n  this.options = u.extend(defaults, opts || {});\n\n  this.setLogLvl = debug.setLogLvl\n\n  this.tracks  = [];    // tracks as numbered array\n  this.lookup  = {};    // tracks as lookup table: lookup['trackname']\n\n  this.muted   = false; // master mute status\n\n  this.context = null;  // AudioContext object (if webAudio is available)\n\n  this.detect  = detect; // external reference to detect object\n\n\n  // File Types\n  // ********************************************************\n\n  for (var i = this.options.fileTypes.length - 1; i >= 0; i--) {\n    if(!detect.audioTypes[ this.options.fileTypes[i] ])\n      this.options.fileTypes.splice(i, 1);\n  }\n\n  if(this.options.fileTypes.length <= 0) {\n    console.warn('Can’t initialize: none of the specified audio types can play in this browser.')\n    return;\n  }\n\n\n  // Initialize\n  // ********************************************************\n\n  if(detect.webAudio){\n    this.context = (typeof AudioContext === 'function' ? new window.AudioContext() : new window.webkitAudioContext() )\n  }\n\n  debug.log(1, 'initialized,', (detect.webAudio ? 'Web Audio Mode,' : 'HTML5 Mode,'), 'can play:', this.options.fileTypes)\n\n  return this\n\n};\n\n/*\n\n  Event Functionality\n\n*/\nMix.prototype.on = u.events.on;\nMix.prototype.one = u.events.one;\nMix.prototype.off = u.events.off;\nMix.prototype.trigger = u.events.trigger;\n\n\n/**************************************************************************\n\n  Track Management\n\n**************************************************************************/\n\nMix.prototype.createTrack = function(name, opts) {\n  var mix = this;\n\n  if(!name){\n    debug.log(0, 'Can’t create track with no name');\n    return;\n  }\n\n  if(mix.lookup[name]) {\n    debug.log(0, 'a track named “' + mix.name + '” already exists')\n    return;\n  }\n\n  var track = mix.options.html5 ? new html5Track(name, opts, mix) : new Track(name, opts, mix);\n\n  mix.tracks.push(track);\n  mix.lookup[name] = track;\n\n  return track;\n};\n\n\n\n\nMix.prototype.removeTrack = function(_input) {\n\n  var mix = this;\n\n  // _input can be either a string or a track object\n  var trackName;\n  if(typeof _input === 'string')\n    trackName = _input\n  else if(typeof _input === 'object' && _input.name)\n    trackName = _input.name\n\n  var track = mix.lookup[trackName];\n\n  if(!track) {\n    debug.log(1, 'can’t remove \"' + trackName + '\", it doesn’t exist');\n    return;\n  }\n\n\n  var rest  = [];\n  var arr   = mix.tracks;\n  var total = arr.length;\n\n  for (var i = 0; i < total; i++) {\n    if(arr[i] && arr[i].name === trackName) {\n      rest = arr.slice(i + 1 || total);\n      arr.length = (i < 0) ? (total + i) : (i);\n      arr.push.apply(arr, rest);\n    }\n  }\n\n  track.pause();\n  track.events = [];\n\n  // stop memory leaks!\n  if(track.element)\n    track.element.src = '';\n\n  track.trigger('remove', mix);\n\n  track = null;\n  delete mix.lookup[trackName];\n  debug.log(1, 'Removed track \"' + trackName + '\"');\n\n};\n\n\nMix.prototype.getTrack = function(name) {\n  return this.lookup[name] || false;\n};\n\n\n\n\n\n/**************************************************************************\n\n  Global Mix Control\n\n**************************************************************************/\n\nMix.prototype.pause = function() {\n\n  debug.log(1, 'Pausing ' + this.tracks.length + ' track(s) ||')\n\n  for (var i = 0; i < this.tracks.length; i++)\n    this.tracks[i].pause()\n};\n\nMix.prototype.play = function() {\n\n  debug.log(1, 'Playing ' + this.tracks.length + ' track(s) >')\n\n  for (var i = 0; i < this.tracks.length; i++)\n    this.tracks[i].play()\n};\n\nMix.prototype.stop = function() {\n\n  debug.log(1, 'Stopping ' + this.tracks.length + ' track(s) .')\n\n  for (var i = 0; i < this.tracks.length; i++)\n     this.tracks[i].stop()\n};\n\n\n\n\nMix.prototype.mute = function() {\n  if(this.muted) return\n  this.muted = true\n  debug.log(1, 'Muting ' + this.tracks.length + ' tracks')\n  for (var i = 0; i < this.tracks.length; i++)\n    this.tracks[i].mute();\n};\n\n\nMix.prototype.unmute = function() {\n  if(!this.muted) return\n  this.muted = false\n  debug.log(1, 'Unmuting ' + this.tracks.length + ' tracks')\n  for (var i = 0; i < this.tracks.length; i++)\n    this.tracks[i].unmute();\n};\n\n\n\nMix.prototype.gain = function(masterGain) {\n  if(typeof masterGain === 'number') {\n    masterGain = u.constrain(masterGain, 0, 1);\n    this.options.gain = masterGain;\n\n    // tracks multiply their gain by the mix’s gain, so when\n    // we change the master gain we need to call track.gain()\n    // to get the intended result\n    for (var i = 0; i < this.tracks.length; i++)\n      this.tracks[i].gain(this.tracks[i].gain());\n  }\n\n  return this.options.gain;\n}\n\n\n\n\n/**************************************************************************\n\n  Utilities\n\n**************************************************************************/\n\n\n// call this using requestanimationframe\nMix.prototype.updateTween = function() {\n  TWEEN.update();\n};\n\n\n\n\nMix.prototype.report = function(){\n  var report = \"\"\n  for (var i = 0; i < this.tracks.length; i++) {\n    report += this.tracks[i].gain() + '\\t' + this.tracks[i].currentTime() + '\\t' + this.tracks[i].name + '\\n'\n  }\n  console.log(report)\n}\n\n\n\n\n\nmodule.exports = Mix;","/*\n\n  HTML5 Track\n\n    wrapper for html5 media element\n\n*/\n\nvar u = require('./utils')\nvar detect = require('./detect')\nvar debug = require('./debug');\n\nvar Track = function(name, opts, mix) {\n\n  console.log('HTML5 TRACK');\n\n  var track = this;\n\n  var defaults = {\n\n    source: false,   // path to audio source (without file extension) OR html5 <audio> or <video> element\n\n    gain:        1,  // initial/current gain (0-1)\n\n    start:       0,  // start time in seconds\n    cachedTime:  0,  // local current time (cached for resuming from pause)\n    startTime:   0,  // time started (cached for accurately reporting currentTime)\n\n    looping:  false, //\n    autoplay: true,  // play immediately on load\n    muted:    (mix.muted) ? true : false\n  };\n\n  // override option defaults\n  track.options = u.extend(defaults, opts || {});\n\n  track.name = name;\n\n  // Status\n  track.status = {\n    loaded:  false,\n    ready:   false,\n    playing: false\n  }\n\n  track.mix = mix;  // reference to parent\n\n  track.events = {};\n  track.tweens = {};\n\n  track.element = undefined; // html5 <audio> or <video> element\n\n\n  debug.log(1, 'createTrack \"' + track.name + '\", mode: \"html5\", autoplay: ' + track.options.autoplay);\n\n  // Load\n  // ~~~~\n\n  if(typeof track.options.source === 'string' && track.options.source.indexOf('blob:') !== 0) {\n    // append extension only if it’s a file path\n    track.options.source  += track.mix.options.fileTypes[0];\n\n    track.element = document.createElement('audio');\n\n  } else if(typeof track.options.source === 'object') {\n    track.element = track.options.source;\n    track.source = track.element.src;\n  }\n\n  track.useElement();\n\n};\n\n\n/*\n\n  Event Functionality\n\n*/\nTrack.prototype.on = u.events.on;\nTrack.prototype.one = u.events.one;\nTrack.prototype.off = u.events.off;\nTrack.prototype.trigger = u.events.trigger;\n\n\n\n\n\n\n/*\n\n  Load\n\n*/\nTrack.prototype.useElement = function() {\n  var track = this;\n  track.element.crossOrigin = '';\n\n  // Add options if they're set.\n  if (track.options.looping)  track.element.loop  = true;\n  if (track.options.muted)    track.element.muted = true;\n  if (track.options.autoplay) track.element.autoplay = true;\n\n  // Event listeners\n  var ready = function() {\n    track.status.loaded = true\n    if(track.options.autoplay) track.play();\n    track.trigger('load', track);\n  }\n\n  track.element.addEventListener('load', ready, false);\n  track.element.addEventListener('canplaythrough', ready, false);\n\n  track.element.addEventListener('error', function() { track.trigger('loadError') });\n\n  track.element.src = track.options.source;\n  track.element.load();\n}\n\n\n\n/*\n\n  Play\n\n*/\nTrack.prototype.play = function() {\n\n  var track = this;\n\n  debug.log(1, 'Playing track \"' + track.name + '\" >')\n\n  track.gain(track.options.gain);\n\n  track.status.ready = true;\n  track.element.play();\n  track.trigger('play', track);\n\n  return track\n}\n\n\n/*\n\n  Pause\n\n*/\n\nTrack.prototype.pause = function(at) {\n  var track = this;\n  if(!track.status.ready || !track.status.playing) return;\n\n  track.element.pause();\n  debug.log(2, 'Pausing track \"' + track.name + '\" at ' + track.options.cachedTime)\n  track.trigger('pause', track);\n\n  return track\n}\n\n\n//  #### ###### ######  ######\n// ##      ##  ##    ## ##   ##\n//  ####   ##  ##    ## ######\n//     ##  ##  ##    ## ##\n// #####   ##   ######  ##\n\nTrack.prototype.stop = function() {\n  var track = this;\n\n  if(!track.status.ready || !track.status.playing) return;\n\n  track.element.pause();\n  track.element.currentTime = 0;\n\n  track.status.playing = false;\n  track.trigger('stop', track);\n\n  debug.log(2, 'Stopping track \"' + track.name)\n\n  return track\n}\n\n\n\n\n\nfunction dummy(){ return this }\n\nTrack.prototype.pan = dummy\nTrack.prototype.tweenPan = dummy\n\n\n\n//  #####   #####  #### ###  ##\n// ##      ##   ##  ##  #### ##\n// ##  ### #######  ##  ## ####\n// ##   ## ##   ##  ##  ##  ###\n//  #####  ##   ## #### ##   ##\n\n// Gain getter/setter\nTrack.prototype.gain = function(val) {\n  var track = this;\n\n  if(typeof val === 'number') {\n\n    val = u.constrain(val, 0, 1); // normalize value\n\n    track.element.volume = val * track.mix.options.gain;\n\n    debug.log(2, '\"' + track.name + '\" setting gain to ' + track.options.gain);\n    track.trigger('gain', track.options.gain, track);\n\n    return track;\n  }\n\n  return track.element.volume\n}\n\nTrack.prototype.tweenGain = function(_val, _tweenDuration) {\n  var track = this;\n  return new Promise(function(resolve, reject){\n    if(typeof _val !== 'number' || typeof _tweenDuration !== 'number') reject(Error('Invalid value for duration.'))\n    debug.log(2, '\"' + track.name + '\" tweening gain ' + track.options.gain + ' -> ' + _val + ' ('+_tweenDuration+'ms)')\n\n    // replace existing gain tween\n    if(track.tweens.gain) track.tweens.gain.stop()\n\n    track.tweens.gain = new TWEEN.Tween({ currentGain: track.options.gain })\n      .to({ currentGain: _val }, _tweenDuration)\n      .easing(TWEEN.Easing.Sinusoidal.InOut)\n      .onUpdate(function() {\n        track.gain(this.currentGain)\n      })\n      .onComplete(function() {\n        resolve(track)\n      })\n      .start()\n\n  })\n}\n\nTrack.prototype.mute = function() {\n  this.options.muted = true;\n  return this;\n}\n\nTrack.prototype.unmute = function() {\n  this.element.muted = false;\n  return this;\n}\n\n\n\n/*\n\n  ###### #### ###  ### ######\n    ##    ##  ######## ##\n    ##    ##  ## ## ## #####\n    ##    ##  ##    ## ##\n    ##   #### ##    ## ######\n\n*/\n\n// set/get\nTrack.prototype.currentTime = function(setTo) {\n  if(!this.status.ready) return;\n  var track = this;\n\n  if(typeof setTo === 'number') {\n    debug.log(2, 'setting track \"' + track.name + '\" to time', setTo)\n    track.element.currentTime = setTo;\n    return track\n  }\n\n  return track.element.currentTime;\n}\n\n// 00:01/00:02\nTrack.prototype.formattedTime = function(includeDuration) {\n  if(includeDuration)\n    return u.timeFormat(this.currentTime()) + '/' + u.timeFormat(this.duration());\n  else\n    return u.timeFormat(this.currentTime());\n}\n\nTrack.prototype.duration = function() {\n  return this.element.duration || 0;\n}\n\nmodule.exports = Track;\n","/*\n\n  ###### #####   #####   ##### ##  ##\n    ##   ##  ## ##   ## ##     ## ##\n    ##   #####  ####### ##     ####\n    ##   ##  ## ##   ## ##     ## ##\n    ##   ##  ## ##   ##  ##### ##  ##\n\n*/\n\nvar u = require('./utils')\nvar detect = require('./detect')\nvar debug = require('./debug');\n\nvar Track = function(name, opts, mix) {\n  console.log('REGULAR TRACK');\n\n  this.defaults = {\n\n    sourceMode: 'buffer', // buffer or (media) element\n\n    source: false,   // either path to audio source (without file extension) or b) html5 <audio> or <video> element\n\n    nodes:      [],  // array of strings: names of desired additional audio nodes\n\n    gain:        1,  // initial/current gain (0-1)\n    gainCache:   false,  // for resuming from mute\n\n    pan:         0,  // circular horizontal pan\n\n    panX:        0,  // real 3d pan\n    panY:        0,  //\n    panZ:        0,  //\n\n    start:       0,  // start time in seconds\n    cachedTime:  0,  // local current time (cached for resuming from pause)\n    startTime:   0,  // time started (cached for accurately reporting currentTime)\n\n    looping:  false, //\n    autoplay: true,  // play immediately on load\n    muted:    (mix.muted) ? true : false\n  };\n\n  // override option defaults\n  this.options = u.extend(this.defaults, opts || {});\n\n  if(this.options.gainCache === false)\n    this.options.gainCache = this.options.gain\n\n  this.name = name;\n\n  // Status\n  this.status = {\n    loaded:  false,\n    ready:   false,\n    playing: false\n  }\n\n  this.mix     = mix;  // reference to parent\n\n  this.events  = {};\n  this.tweens  = {};\n  this.nodes   = undefined;   // holds the web audio nodes (gain and pan are defaults, all other optional)\n\n  this.onendtimer = undefined;  // web audio api in chrome doesn't support onend event yet :(\n\n  this.element = undefined; // html5 <audio> or <video> element\n  this.source  = undefined; //  web audio source:\n\n  if(typeof this.options.source === 'string' && this.options.source.indexOf('blob:') !== 0) {\n    // append extension only if it’s a file path\n    this.options.source  += this.mix.options.fileTypes[0];\n  } else if(typeof this.options.source === 'object') {\n    // otherwise switch mode to element\n    this.options.sourceMode = 'element'\n  }\n\n  debug.log(1, 'createTrack \"' + this.name + '\", mode: \"' + this.options.sourceMode + '\", autoplay: ' + this.options.autoplay);\n\n\n\n  // Load\n  // ~~~~\n\n  if(detect.webAudio === true) {\n\n    // Web Audio\n\n    if(!this.options.source) {\n      debug.log(1, 'Creating track \"' + name + '\" without a source');\n      return;\n    }\n\n    if(this.options.sourceMode === 'buffer') {\n\n      this.loadBufferSource()\n\n    } else if(this.options.sourceMode === 'element') {\n\n      if(typeof this.options.source === 'object')\n        this.useHTML5elementSource()\n      else\n        this.createHTML5elementSource()\n\n    }\n\n  } else {\n\n    // HTML5\n\n    debug.log(1, 'creating html5 element for track ' + name);\n\n    // Look for pre-created audio element and failing that create one\n    this.element = document.querySelector('audio#' + name);\n\n    if(!this.element) {\n      var el = document.createElement('audio');\n      el.id = name;\n      document.body.appendChild(el);\n      this.element = document.querySelector('audio#' + name);\n    }\n\n    var canplay = function() {\n      if(this.status.loaded) return;\n\n      this.status.loaded = true;\n      this.status.ready = true;\n\n      if(!this.options.autoplay)\n        this.pause();\n\n      this.trigger('load', this);\n    }\n\n    var _this = this\n\n    // canplaythrough listener\n    _this.element.addEventListener('canplaythrough', canplay, false);\n    _this.element.addEventListener('load',           canplay, false);\n\n    // Looping\n    _this.element.addEventListener('ended', function() {\n\n      if(_this.options.looping) {\n\n        debug.log(2, 'Track ' + _this.name + ' looping')\n\n        _this.element.currentTime = 0;\n        _this.element.play();\n\n      } else {\n\n        _this.trigger('ended', _this);\n        _this.mix.removeTrack(_this.name);\n      }\n\n    }, false);\n\n    this.createHTML5elementSource(this.options.source);\n  }\n};\n\n\n/*\n\n  Event Functionality\n\n*/\nTrack.prototype.on = u.events.on;\nTrack.prototype.one = u.events.one;\nTrack.prototype.off = u.events.off;\nTrack.prototype.trigger = u.events.trigger;\n\n\n\n\n\n\n// ##    ######   #####  ######\n// ##   ##    ## ##   ## ##   ##\n// ##   ##    ## ####### ##   ##\n// ##   ##    ## ##   ## ##   ##\n// ##### ######  ##   ## ######\n\n// Create out-of-DOM html5 <audio> element as source\nTrack.prototype.createHTML5elementSource = function() {\n\n  var _this = this;\n  if(!_this.options.source) return;\n\n  debug.log(2, 'Track \"' + this.name + '\" creating HTML5 element source: \"' + _this.options.source + _this.mix.options.fileTypes[0]  + '\"');\n  _this.status.ready = false\n\n  var src = _this.options.source\n\n  _this.options.source = document.createElement('audio')\n  _this.options.source.crossOrigin = ''\n  _this.options.source.src = src\n\n  _this.useHTML5elementSource()\n}\n\n// Use existing in-DOM html5 <audio> or <video> element as source\nTrack.prototype.useHTML5elementSource = function() {\n\n  var _this = this;\n  if(!_this.options.source) return;\n\n  debug.log(2, 'Track \"' + this.name + '\" use HTML5 element source: \"' + _this.options.source + '\"')\n\n  _this.element = _this.options.source\n  _this.options.source.crossOrigin = ''\n  _this.options.source = _this.element.src\n\n  /**\n   * Add options if they're set.\n   */\n  if (_this.options.looping) { _this.element.loop  = true; }\n  if (_this.options.muted)   { _this.element.muted = true; }\n\n  if(_this.mix.context)\n    _this.source = _this.mix.context.createMediaElementSource(_this.element);\n\n  var ready = function() {\n    _this.status.loaded = true\n    if(_this.options.autoplay) _this.play();\n    _this.trigger('load', _this);\n  }\n\n  _this.element.addEventListener('canplaythrough', ready)\n  _this.element.addEventListener('error', function() { _this.trigger('loadError') })\n\n  _this.element.load()\n\n  return _this\n}\n\nTrack.prototype.loadBufferSource = function(forcePlay) {\n\n  var _this = this;\n  if(!_this.options.source) return;\n\n  debug.log(2, 'Track \"' + this.name + '\" webAudio source: \"' + _this.options.source + '\"')\n\n  var request = new XMLHttpRequest();\n  request.open('GET', _this.options.source, true);\n  request.responseType = 'arraybuffer';\n\n  // asynchronous callback\n  request.onload = function() {\n    debug.log(2, '\"' + _this.name + '\" loaded \"' + _this.options.source + '\"');\n    _this.options.audioData = request.response; // cache the audio data\n    _this.status.loaded = true;\n    _this.trigger('load', _this);\n    if(forcePlay){\n      _this.play(true)\n    } else {\n      if(_this.options.autoplay) _this.play();\n    }\n  }\n\n  request.onerror = function() {\n    debug.log(1, 'couldn’t load track \"' + _this.name + '\" with source \"' + _this.options.source + '\"')\n    _this.trigger('loadError', _this)\n  }\n\n  request.send();\n}\n\n\n\n\n\n\n\n\n\n// ###  ##  ######  ######  ######  ####\n// #### ## ##    ## ##   ## ##     ##\n// ## #### ##    ## ##   ## #####   ####\n// ##  ### ##    ## ##   ## ##         ##\n// ##   ##  ######  ######  ###### #####\n\n\n// AudioNode Creation\n// -> this function can be chained\n\nTrack.prototype.addNode = function(nodeType) {\n\n  var _this = this;\n\n  // if this is the first time we’re calling addNode, connect directly to the source\n  if(!_this.nodes.lastnode) _this.nodes.lastnode = _this.source;\n\n  debug.log(2, ' +  addNode ' + nodeType);\n\n  // Analyser and Processor ********************************************************\n\n  if(nodeType === 'analyse') {\n\n    // create a script processor with bufferSize of 2048\n    _this.nodes.processor = _this.mix.context.createScriptProcessor(2048, 1, 1)\n\n    // create an analyser\n    _this.nodes.analyser = _this.mix.context.createAnalyser()\n    _this.nodes.analyser.smoothingTimeConstant = 0.5\n    _this.nodes.analyser.fftSize = 32\n\n    _this.nodes.processor.connect(_this.mix.context.destination) // processor -> destination\n    _this.nodes.analyser.connect(_this.nodes.processor)          // analyser -> processor\n\n    // define a Uint8Array to receive the analyser’s data\n    _this.options.bufferLength = new Uint8Array(_this.nodes.analyser.frequencyBinCount)\n    var analyserData = new Uint8Array(_this.options.bufferLength)\n\n    _this.nodes.lastnode.connect(_this.nodes.analyser)\n\n    _this.nodes.processor.onaudioprocess = function(){\n      _this.nodes.analyser.getByteTimeDomainData(analyserData)\n      _this.trigger('analyse', analyserData)\n    }\n  }\n\n  // Gain ********************************************************\n  // http://www.w3.org/TR/webaudio/#GainNode\n\n  else if(nodeType === 'gain') {\n\n    if(_this.mix.context.createGainNode)\n      _this.nodes.gain = _this.mix.context.createGainNode();\n    else\n      _this.nodes.gain = _this.mix.context.createGain();\n\n    // connect last created node to newly created node\n    _this.nodes.lastnode.connect(_this.nodes.gain);\n\n    // set newly created node to last node in the chain\n    _this.nodes.lastnode = _this.nodes.gain;\n\n  }\n\n  // Panner ********************************************************\n  // http://www.w3.org/TR/webaudio/#PannerNode\n\n  else if(nodeType === 'panner') {\n\n    if(window.AudioContext) {\n\n      _this.nodes.panner = _this.mix.context.createPanner();\n      // _this.nodes.panner.panningModel = 'equalpower';\n      // _this.nodes.panner.panningModel = 'HRTF';\n\n    } else if(window.webkitAudioContext) {\n\n      _this.nodes.panner = _this.mix.context.createPanner();\n      // _this.nodes.panner.panningModel = webkitAudioPannerNode.EQUALPOWER;\n      // _this.nodes.panner.panningModel = _this.nodes.panner.EQUALPOWER;\n\n    } else {\n      return _this;\n    }\n\n    _this.nodes.lastnode.connect(_this.nodes.panner);\n    _this.nodes.lastnode = _this.nodes.panner;\n\n  }\n\n  // Convolver (Reverb etc) **********************************************\n  // http://www.w3.org/TR/webaudio/#ConvolverNode\n\n  else if(nodeType === 'convolver') {\n\n    if(!_this.mix.context.createConvolver) return _this;\n\n    _this.nodes.convolver = _this.mix.context.createConvolver();\n\n    // TODO: implement loading impulse response for the convolver node\n    // http://chromium.googlecode.com/svn/trunk/samples/audio/impulse-responses/\n\n    // _this.nodes.convolver.buffer = convolverBuffer;\n\n\n  }\n\n  // Compressor ********************************************************\n  // http://www.w3.org/TR/webaudio/#DynamicsCompressorNode\n\n  else if(nodeType === 'compressor') {\n\n    _this.nodes.compressor = _this.mix.context.createDynamicsCompressor();\n\n    // no settings required really…\n\n    _this.nodes.lastnode.connect(_this.nodes.compressor);\n    _this.nodes.lastnode = _this.nodes.compressor;\n\n  }\n\n  // Delay ********************************************************\n  // http://www.w3.org/TR/webaudio/#DelayNode\n\n  else if(nodeType === 'delay') {\n\n    if(detect.nodes.delayNode)\n      _this.nodes.delay = _this.mix.context.createDelayNode();\n    else\n      _this.nodes.delay = _this.mix.context.createDelay();\n\n    _this.nodes.delay.delayTime = 0;\n\n    _this.nodes.lastnode.connect(_this.nodes.delay);\n    _this.nodes.lastnode = _this.nodes.delay;\n\n  }\n\n  // it’s chainable\n  return _this;\n}\n\n\n// ######  ##     ##### ##    ##\n// ##   ## ##    ##   ## ##  ##\n// ######  ##    #######  ####\n// ##      ##    ##   ##   ##\n// ##      ##### ##   ##   ##\n\nTrack.prototype.play = function(bufferSourceLoaded) {\n\n  var _this = this;\n\n  if(!_this.status.loaded) {\n    debug.log(1, 'Can’t play track \"' + _this.name + '\", not loaded')\n    return;\n  }\n\n  if(_this.status.playing === true) return;\n  _this.status.playing = true;\n\n  if(!detect.webAudio)\n    playSingleElement(_this)\n\n  else if(detect.webAudio && _this.options.sourceMode === 'buffer'){\n    // need to re-xhr the audio file so we loop back to load\n    if(bufferSourceLoaded)\n      playBufferSource(_this)\n    else {\n      _this.status.playing = false;\n      _this.loadBufferSource(true) // loop back to load\n    }\n  }\n\n  else if(detect.webAudio && _this.options.sourceMode === 'element')\n    playElementSource(_this)\n\n\n  return _this\n}\n\n\nfunction playCreateNodes(_this) {\n\n  debug.log(2, 'Creating nodes for track \"' + _this.name + '\"')\n\n  // Create Nodes\n  // ~~~~~~~~~~~~\n\n  _this.nodes = {}\n\n  // 1. Create standard nodes (gain and pan)\n  _this.addNode('panner').addNode('gain')\n\n  // 2. Create additional nodes\n  if(_this.options.nodes.length){\n    for (var i = 0; i < _this.options.nodes.length; i++) {\n      _this.addNode( _this.options.nodes[i] );\n    }\n  }\n\n  // 3. Connect the last node in the chain to the destination\n  _this.nodes.lastnode.connect(_this.mix.context.destination);\n\n}\n\n// ********************************************************\n\nfunction playElementSource(_this) {\n\n  // unlike buffer mode, we only need to construct the nodes once\n  if( !_this.nodes ) {\n\n    playCreateNodes(_this)\n\n    // we also only want one event listener\n    _this.element.addEventListener('ended', function() {\n      _this.trigger('ended', _this)\n    }, false)\n  }\n\n\n  // Apply Options\n  // ~~~~~~~~~~~~~~\n\n  _this.status.ready = true;\n  _this.trigger('ready', _this);\n\n  if(_this.options.looping) _this.element.loop = true;\n  else                      _this.element.loop = false;\n\n  _this.gain(_this.options.gain)\n  _this.pan(_this.options.pan)\n\n  // Start Time\n\n  _this.options.startTime = _this.element.currentTime - _this.options.cachedTime;\n  var startFrom = _this.options.cachedTime || 0;\n\n  debug.log(1, 'Playing track \"' + _this.name + '\" from ' + startFrom + ' (' + _this.options.startTime + ') gain ' + _this.gain());\n\n  // Play!\n\n  _this.element.currentTime = startFrom;\n  _this.element.play()\n\n  _this.trigger('play', _this)\n\n}\n\n\n// ********************************************************\n\nfunction setEndTimer(){\n  var _this = this\n  var startFrom = _this.options.cachedTime || 0\n  var timerDuration = (_this.source.buffer.duration - startFrom)\n\n  _this.onendtimer = setTimeout(function() {\n    _this.trigger('ended', _this)\n\n    if(_this.options.looping){\n\n      if(bowser && bowser.chrome && Math.floor(bowser.version) >= 42){\n        // HACK chrome 42+ looping fix\n        _this.stop()\n        _this.play()\n      } else {\n        setEndTimer.call(_this)\n      }\n\n    }\n\n  }, timerDuration * 1000)\n}\n\nfunction playBufferSource(_this) {\n\n  _this.status.ready = false\n\n  // Construct Audio Buffer\n  // ~~~~~~~~~~~~~~~~~~~~~~\n\n  // (we have to re-construct the buffer every time we begin play)\n\n  _this.source = null\n\n  // *sigh* async makes for such messy code\n  var finish = function() {\n\n    playCreateNodes(_this)\n\n    _this.status.ready = true;\n    _this.trigger('ready', _this);\n\n    // Apply Options\n    _this.source.loop = (_this.options.looping) ? true : false\n    _this.gain(_this.options.gain)\n    _this.pan(_this.options.pan)\n\n\n    // Play\n    // ~~~~\n\n    _this.options.startTime = _this.source.context.currentTime - _this.options.cachedTime;\n    var startFrom = _this.options.cachedTime || 0;\n\n    debug.log(2, 'Playing track \"' + _this.name + '\" from ' + startFrom + ' (' + _this.options.startTime + ') gain ' + _this.gain());\n\n    // prefer start() but fall back to deprecated noteOn()\n    if(typeof _this.source.start === 'function') _this.source.start(0, startFrom);\n    else                                         _this.source.noteOn(startFrom);\n\n    // fake ended event\n    _this.onendtimer = false\n    setEndTimer.call(_this)\n\n\n    _this.trigger('play', _this)\n\n  }\n\n\n  // Create source\n  // ~~~~~~~~~~~~~\n\n  // W3C standard implementation (Firefox, recent Chrome)\n  if(typeof _this.mix.context.createGain === 'function') {\n\n    _this.mix.context.decodeAudioData(_this.options.audioData, function(decodedBuffer){\n      if(_this.status.ready) return\n\n      _this.source        = _this.mix.context.createBufferSource();\n      var sourceBuffer    = decodedBuffer;\n      _this.source.buffer = sourceBuffer;\n\n      finish()\n    })\n  }\n\n  // Non-standard Webkit implementation (Safari, old Chrome)\n  else if(typeof _this.mix.context.createGainNode === 'function') {\n\n    _this.source = _this.mix.context.createBufferSource();\n    var sourceBuffer  = _this.mix.context.createBuffer(_this.options.audioData, true);\n    _this.source.buffer = sourceBuffer;\n\n    finish()\n  }\n}\n\n// ********************************************************\n\nfunction playSingleElement(_this) {\n\n  debug.log(1, 'Playing track \"' + _this.name + '\" >')\n\n  _this.gain(_this.options.gain)\n\n  _this.status.ready  = true;\n  _this.element.play();\n  _this.trigger('play', _this);\n}\n\n\n// ######   #####  ##   ##  ####  ######\n// ##   ## ##   ## ##   ## ##     ##\n// ######  ####### ##   ##  ####  #####\n// ##      ##   ## ##   ##     ## ##\n// ##      ##   ##  #####  #####  ######\n\n\nTrack.prototype.pause = function(at) {\n\n  if(!this.status.ready || !this.status.playing) return;\n\n  var _this = this;\n\n  // cache time to resume from later\n  if(typeof at === 'number') _this.options.cachedTime = at;\n  else                         _this.options.cachedTime = _this.currentTime();\n\n  _this.status.playing = false;\n\n  if(_this.onendtimer) clearTimeout(_this.onendtimer);\n\n  if(detect.webAudio === true) {\n\n    if(_this.options.sourceMode === 'buffer') {\n\n      // prefer stop(), fallback to deprecated noteOff()\n      if(typeof _this.source.stop === 'function')\n        _this.source.stop(0);\n      else if(typeof _this.source.noteOff === 'function')\n        _this.source.noteOff(0);\n\n    } else if(_this.options.sourceMode === 'element') {\n\n      _this.element.pause()\n    }\n\n  } else {\n\n    _this.element.pause();\n  }\n\n  debug.log(2, 'Pausing track \"' + _this.name + '\" at ' + _this.options.cachedTime)\n  _this.trigger('pause', _this);\n\n  return _this\n}\n\n\n//  #### ###### ######  ######\n// ##      ##  ##    ## ##   ##\n//  ####   ##  ##    ## ######\n//     ##  ##  ##    ## ##\n// #####   ##   ######  ##\n\nTrack.prototype.stop = function() {\n\n  if(!this.status.ready || !this.status.playing) return;\n\n  var _this = this;\n\n  if(!_this.status.playing) return\n\n  if(_this.onendtimer) clearTimeout(_this.onendtimer)\n\n  _this.options.cachedTime = _this.options.startTime = 0\n\n  if(detect.webAudio === true && _this.options.sourceMode === 'buffer') {\n\n    // prefer stop(), fallback to deprecated noteOff()\n    if(typeof _this.source.stop === 'function')\n      _this.source.stop(0);\n    else if(typeof _this.source.noteOff === 'function')\n      _this.source.noteOff(0);\n\n  } else {\n\n    _this.options.autoplay = false;\n\n    _this.element.pause();\n    _this.element.currentTime = 0;\n  }\n\n  debug.log(2, 'Stopping track \"' + _this.name)\n  _this.status.playing = false\n  _this.trigger('stop', _this);\n\n  _this.options.gain = _this.options.gainCache;\n\n  return _this\n\n}\n\n\n// ######   #####  ###  ##\n// ##   ## ##   ## #### ##\n// ######  ####### ## ####\n// ##      ##   ## ##  ###\n// ##      ##   ## ##   ##\n\n// proper 3d stereo panning\nTrack.prototype.pan = function(angleDeg) {\n\n  if( !detect.webAudio || !this.status.ready || !this.nodes.panner ) return\n\n  if(typeof angleDeg === 'string') {\n    if(     angleDeg === 'front') angleDeg =   0;\n    else if(angleDeg === 'back' ) angleDeg = 180;\n    else if(angleDeg === 'left' ) angleDeg = 270;\n    else if(angleDeg === 'right') angleDeg =  90;\n  }\n\n  if(typeof angleDeg === 'number') {\n\n    this.options.pan = angleDeg % 360;\n\n    var angleRad = (-angleDeg + 90) * 0.017453292519943295; // * PI/180\n\n    var x = this.options.panX = Math.cos(angleRad);\n    var y = this.options.panY = Math.sin(angleRad);\n    var z = this.options.panZ = -0.5;\n\n    this.nodes.panner.setPosition(x, y, z);\n\n    this.trigger('pan', this.options.pan, this)\n\n    return this // all setters should be chainable\n  }\n\n  return this.options.pan\n}\n\nTrack.prototype.tweenPan = function(angleDeg, tweenDuration) {\n  var _this = this;\n\n  return new Promise(function(resolve, reject){\n    if( !detect.tween || !detect.webAudio || !_this.status.ready || !_this.nodes.panner ) reject(Error('nope nope nope'))\n    if( typeof angleDeg !== 'number' || typeof tweenDuration !== 'number' ) reject(Error('Not a valid tween duration.'))\n\n    debug.log(2, '\"' + _this.name + '\" tweening pan2d')\n\n    if(_this.tweens.pan) _this.tweens.pan.stop()\n\n    _this.tweens.pan = new TWEEN.Tween({ currentAngle: _this.options.pan })\n      .to({ currentAngle: angleDeg }, tweenDuration)\n      .easing(TWEEN.Easing.Sinusoidal.InOut)\n      .onUpdate(function() {\n        _this.pan(this.currentAngle)\n      })\n      .onComplete(function() {\n        resolve(_this)\n      })\n      .start()\n\n    return _this\n\n  })\n}\n\n\n//  #####   #####  #### ###  ##\n// ##      ##   ##  ##  #### ##\n// ##  ### #######  ##  ## ####\n// ##   ## ##   ##  ##  ##  ###\n//  #####  ##   ## #### ##   ##\n\n// cache current gain for restoring later\nTrack.prototype.gainCache = function(setTo) {\n  if(typeof setTo === 'number') {\n    this.options.gainCache = setTo;\n    return this\n  } else {\n    return this.options.gainCache\n  }\n}\n\n// gain range 0-1\nTrack.prototype.gain = function(val) {\n  if(typeof val === 'number') {\n\n    val = u.constrain(val, 0, 1) // normalize value\n\n    if(this.options.muted) {\n      this.gainCache(val) // cache the value\n      this.options.gain = 0\n    } else {\n      this.options.gain = val\n    }\n\n    if(this.status.playing) {\n\n      if(!detect.webAudio)\n        this.element.volume = this.options.gain * this.mix.options.gain\n      else if( this.nodes && this.nodes.gain )\n        this.nodes.gain.gain.value = this.options.gain * this.mix.options.gain\n\n    }\n\n    debug.log(2, '\"' + this.name + '\" setting gain to ' + this.options.gain)\n\n    this.trigger('gain', this.options.gain, this)\n\n    // setters should be chainable\n    return this\n\n  }\n\n  return this.options.gain\n\n}\n\nTrack.prototype.tweenGain = function(_val, _tweenDuration) {\n  var _this = this;\n  return new Promise(function(resolve, reject){\n    if(typeof _val !== 'number' || typeof _tweenDuration !== 'number') reject(Error('Invalid value for duration.'))\n    debug.log(2, '\"' + _this.name + '\" tweening gain ' + _this.options.gain + ' -> ' + _val + ' ('+_tweenDuration+'ms)')\n\n    // replace existing gain tween\n    if(_this.tweens.gain) _this.tweens.gain.stop()\n\n    _this.tweens.gain = new TWEEN.Tween({ currentGain: _this.options.gain })\n      .to({ currentGain: _val }, _tweenDuration)\n      .easing(TWEEN.Easing.Sinusoidal.InOut)\n      .onUpdate(function() {\n        _this.gain(this.currentGain)\n      })\n      .onComplete(function() {\n        resolve(_this)\n      })\n      .start()\n\n  })\n}\n\nTrack.prototype.mute = function() {\n  this.gainCache(this.options.gain)\n  this.gain(0)\n  this.options.muted = true\n  if(this.options.sourceMode === 'element')\n    this.element.muted = true\n  return this\n}\n\nTrack.prototype.unmute = function() {\n  this.options.muted = false;\n  if(this.options.sourceMode === 'element')\n    this.element.muted = false\n  this.gain(this.options.gainCache)\n  return this\n}\n\n\n//  ##### ##   ## #####  ###### ###  ## ###### ###### #### ###  ### ######\n// ##     ##   ## ##  ## ##     #### ##   ##     ##    ##  ######## ##\n// ##     ##   ## #####  #####  ## ####   ##     ##    ##  ## ## ## #####\n// ##     ##   ## ##  ## ##     ##  ###   ##     ##    ##  ##    ## ##\n//  #####  #####  ##  ## ###### ##   ##   ##     ##   #### ##    ## ######\n\nTrack.prototype.currentTime = function(setTo) {\n  if(!this.status.ready) return;\n\n  if(typeof setTo === 'number') {\n\n    debug.log(2, 'setting track \"' + this.name + '\" to time', setTo)\n\n    if(detect.webAudio && this.options.sourceMode === 'buffer') {\n\n      if(this.status.playing) {\n        this.pause(setTo);\n        this.play();\n      } else {\n        this.options.cachedTime = setTo;\n      }\n\n    } else {\n\n      this.element.currentTime = setTo;\n    }\n\n    return this\n  }\n\n  if(!this.status.playing) return this.options.cachedTime || 0;\n\n  if(detect.webAudio && this.options.sourceMode === 'buffer')\n    return this.source.context.currentTime - this.options.startTime || 0;\n  else\n    return this.element.currentTime || 0;\n}\n\n/**************************************************************************\n\n  Getters Only\n\n**************************************************************************/\n\nfunction timeFormat(seconds) {\n  var m = Math.floor(seconds / 60) < 10 ? '0' + Math.floor(seconds / 60) : Math.floor(seconds / 60);\n  var s = Math.floor(seconds - (m * 60)) < 10 ? '0' + Math.floor(seconds - (m * 60)) : Math.floor(seconds - (m * 60));\n  return m + ':' + s;\n}\n\nTrack.prototype.formattedTime = function(includeDuration) {\n  if(!this.status.ready) return;\n\n  if(includeDuration)\n    return timeFormat(this.currentTime()) + '/' + timeFormat(this.duration());\n  else\n    return timeFormat(this.currentTime());\n}\n\nTrack.prototype.duration = function() {\n  if(!this.status.ready) return;\n\n  if(detect.webAudio && this.options.sourceMode === 'buffer')\n    return this.source.buffer.duration || 0;\n  else\n    return this.element.duration || 0;\n}\n\nmodule.exports = Track;","/*\n\n  Utils\n\n*/\n\nvar u = {};\nmodule.exports = u;\n\n\nu.extend = function() {\n  var output = {}\n  var args = arguments\n  var l = args.length\n\n  for (var i = 0; i < l; i++)\n    for (var key in args[i])\n      if(args[i].hasOwnProperty(key))\n        output[key] = args[i][key];\n  return output;\n}\n\nu.constrain = function(val, min, max) {\n  if(val < min) return min;\n  if(val > max) return max;\n  return val;\n}\n\n\nu.timeFormat = function(seconds) {\n  var m = Math.floor(seconds / 60) < 10 ? '0' + Math.floor(seconds / 60) : Math.floor(seconds / 60);\n  var s = Math.floor(seconds - (m * 60)) < 10 ? '0' + Math.floor(seconds - (m * 60)) : Math.floor(seconds - (m * 60));\n  return m + ':' + s;\n}\n\n/*\n\n  Events\n\n*/\nu.events = {};\nu.events.on = function(type, callback) {\n  this.events[type] = this.events[type] || [];\n  this.events[type].push(callback);\n\n  return this\n}\n\nu.events.one = function(type, callback) {\n  var _this = this\n  this.events[type] = this.events[type] || [];\n  this.events[type].push(function(){\n    _this.off(type)\n    callback()\n  });\n\n  return this\n}\n\nu.events.off = function(type) {\n  if(type === '*')\n    this.events = {};\n  else\n    this.events[type] = [];\n\n  return this\n}\n\nu.events.trigger = function(type) {\n\n  if(!this.events[type]) return;\n\n  var args = Array.prototype.slice.call(arguments, 1);\n\n  for (var i = 0, l = this.events[type].length; i < l; i++)\n      if(typeof this.events[type][i] === 'function')\n        this.events[type][i].apply(this, args);\n\n}\n\n"]}